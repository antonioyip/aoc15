package main

import (
	"fmt"
	"io/ioutil"
	"strings"
)

func main() {
	inputs, err := ioutil.ReadFile("day19.input")
	if err != nil {
		panic(err)
	}
	lines := strings.Split(string(inputs), "\n")

	machine := map[string]string{}
	var key string
	var replacement string
	for _, line := range lines {
		fmt.Sscanf(line, "%s => %s", &key, &replacement)
		machine[replacement] = key
	}

	testReplace()
	testReduce()

	startMolecule := "CRnCaSiRnBSiRnFArTiBPTiTiBFArPBCaSiThSiRnTiBPBPMgArCaSiRnTiMgArCaSiThCaSiRnFArRnSiRnFArTiTiBFArCaCaSiRnSiThCaCaSiRnMgArFYSiRnFYCaFArSiThCaSiThPBPTiMgArCaPRnSiAlArPBCaCaSiRnFYSiThCaRnFArArCaCaSiRnPBSiRnFArMgYCaCaCaCaSiThCaCaSiAlArCaCaSiRnPBSiAlArBCaCaCaCaSiThCaPBSiThPBPBCaSiRnFYFArSiThCaSiRnFArBCaCaSiRnFYFArSiThCaPBSiThCaSiRnPMgArRnFArPTiBCaPRnFArCaCaCaCaSiRnCaCaSiRnFYFArFArBCaSiThFArThSiThSiRnTiRnPMgArFArCaSiThCaPBCaSiRnBFArCaCaPRnCaCaPMgArSiRnFYFArCaSiThRnPBPMgAr"
	fmt.Println(countReduceSteps(startMolecule, "e", machine))
}

// machine: key is the larger molecule and value the smaller molecule
// input: key is a molecule and the value is the number of reductions applied to arrive at this molecule
// reductions: only check molecules with this number of reductions applied
// return all permutations of molecules generated by reducing the input using the machine; excludes molecules that cannot be reduced
func reduceMolecules(machine map[string]string, input map[string]int, reductions int) map[string]int {
	output := map[string]int{}
	for molecule, steps := range input {
		if steps != reductions {
			continue
		}
		for larger, smaller := range machine {
			for i := 1; true; i++ {
				reduced, newMolecule := replaceNth(molecule, larger, smaller, i)
				if !reduced {
					break
				}
				if _, exists := input[newMolecule]; exists {
					// molecule was already seen in a more efficient reduction
					break
				}
				output[newMolecule] = steps + 1
			}
		}
	}
	return output
}

// replace the nth instance of oldText with newText in input
// return true if nth oldText is found, false otherwise
// return resulting string
func replaceNth(input string, oldText string, newText string, nth int) (bool, string) {
	index := 0
	for i := 1; i <= nth; i++ {
		temp := strings.Index(input[index:], oldText)
		if temp < 0 {
			break
		}
		index += temp
		if i == nth {
			return true, input[:index] + newText + input[index+len(oldText):]
		}
		index += len(oldText)
	}
	return false, ""
}

// count steps to reduce from startMolecule to finalMolecule using machine
// return steps if successfully reduced, -1 otherwise
func countReduceSteps(startMolecule string, finalMolecule string, machine map[string]string) int {
	molecules := map[string]int{startMolecule: 0}

	for i := 0; true; i++ {
		newMolecules := reduceMolecules(machine, molecules, i)
		if len(newMolecules) == 0 {
			// could not reduce further
			break
		}
		if _, ok := newMolecules[finalMolecule]; ok {
			// found solution
			return newMolecules[finalMolecule]
		}
		// join maps
		for k, v := range newMolecules {
			if _, ok := molecules[k]; !ok {
				molecules[k] = v
			}
		}
	}
	return -1
}

func assert(b1 bool, s1 string, b2 bool, s2 string) bool {
	if b1 == b2 {
		if b1 {
			// exists, compare strings
			return s1 == s2
		}
		// does not exist
		return true
	}
	return false
}

func testReplace() {
	b, s := replaceNth("hohoho", "ho", "tree", 1)
	fmt.Println(assert(b, s, true, "treehoho"))

	b, s = replaceNth("hohoho", "ho", "tree", 2)
	fmt.Println(assert(b, s, true, "hotreeho"))

	b, s = replaceNth("hohoho", "ho", "tree", 3)
	fmt.Println(assert(b, s, true, "hohotree"))

	b, s = replaceNth("hohoho", "ho", "tree", 0)
	fmt.Println(assert(b, s, false, ""))

	b, s = replaceNth("hohoho", "ho", "tree", 4)
	fmt.Println(assert(b, s, false, ""))

	b, s = replaceNth("hohoho", "ae", "e", 0)
	fmt.Println(assert(b, s, false, ""))

	b, s = replaceNth("cat dog bird dog cat bird", "cat", "tree", 0)
	fmt.Println(assert(b, s, false, ""))

	b, s = replaceNth("cat dog bird dog cat bird", "cat", "tree", 1)
	fmt.Println(assert(b, s, true, "tree dog bird dog cat bird"))

	b, s = replaceNth("cat dog bird dog cat bird", "cat", "tree", 2)
	fmt.Println(assert(b, s, true, "cat dog bird dog tree bird"))

	b, s = replaceNth("cat dog bird dog cat bird", "cat", "tree", 3)
	fmt.Println(assert(b, s, false, ""))

	b, s = replaceNth("cat dog bird dog cat bird", "dog", "tree", 0)
	fmt.Println(assert(b, s, false, ""))

	b, s = replaceNth("cat dog bird dog cat bird", "dog", "tree", 1)
	fmt.Println(assert(b, s, true, "cat tree bird dog cat bird"))

	b, s = replaceNth("cat dog bird dog cat bird", "dog", "tree", 2)
	fmt.Println(assert(b, s, true, "cat dog bird tree cat bird"))

	b, s = replaceNth("cat dog bird dog cat bird", "dog", "tree", 3)
	fmt.Println(assert(b, s, false, ""))

	b, s = replaceNth("cat dog bird dog cat bird", "bird", "tree", 0)
	fmt.Println(assert(b, s, false, ""))

	b, s = replaceNth("cat dog bird dog cat bird", "bird", "tree", 1)
	fmt.Println(assert(b, s, true, "cat dog tree dog cat bird"))

	b, s = replaceNth("cat dog bird dog cat bird", "bird", "tree", 2)
	fmt.Println(assert(b, s, true, "cat dog bird dog cat tree"))

	b, s = replaceNth("cat dog bird dog cat bird", "bird", "tree", 3)
	fmt.Println(assert(b, s, false, ""))
}

func testReduce() {
	machine := map[string]string{"H": "e", "O": "e", "HO": "H", "OH": "H", "HH": "O"}
	fmt.Println(countReduceSteps("HOHOHO", "e", machine))
}
